type ChainInfo @entity {
  "Name"
  id: ID!
  count: Int!
}

type Block @entity {
  "000000..00<blockNum>-<shorthash>"
  id: ID!
  height: Int! @index
  hash: String! @index
  author: String!
  stateRoot: String!
  parentHash: String!
  extrinsicRoot: String!
  finalized: Boolean! @index
  timestamp: DateTime!
  processorTimestamp: DateTime
  extrinsics: [Extrinsic!] @derivedFrom(field: "block")
  events: [Event!] @derivedFrom(field: "block")
  accounts: [Account!] @derivedFrom(field: "block")
}

type Extrinsic @entity {
  "000000..00<blockNum>-000<index>-<shorthash>"
  id: ID!
  block: Block!
  index: Int!
  hash: String! @index
  args: JSON!
  docs: String!
  method: String! @index
  section: String! @index
  signer: String! @index
  status: ExtrinsicStatus!
  errorMessage: String
  type: ExtrinsicType!
  signedData: JSON
  timestamp: DateTime!
  events: [Event!] @derivedFrom(field: "extrinsic")
  contract: Contract @derivedFrom(field: "extrinsic")
}

type Event @entity {
  "000000..00<blockNum>-000<index>-<shorthash>"
  id: ID!
  extrinsic: Extrinsic!
  block: Block!
  index: Int!
  phase: String!
  section: String! @index
  method: String! @index
  data: JSON!
  timestamp: DateTime!
}

type Account @entity {
  "Native address"
  id: ID!
  evmAddress: String @index
  block: Block!
  identity: JSON
  active: Boolean! @index
  freeBalance: BigInt!
  lockedBalance: BigInt!
  availableBalance: BigInt!
  reservedBalance: BigInt!
  vestedBalance: BigInt!
  votingBalance: BigInt!
  nonce: Int!
  evmNonce: Int!
  timestamp: DateTime!
  contracts: [Contract!] @derivedFrom(field: "signer")
}

type Contract @entity {
  "Address"
  id: ID!
  extrinsic: Extrinsic! @unique
  signer: Account!
  bytecode: String!
  bytecodeContext: String!
  bytecodeArguments: String!
  gasLimit: Int!
  storageLimit: Int!
  timestamp: DateTime!
}

# type EvmEvent @entity {
#   id: ID! # 000000..00<blockNum>-000<index>-<shorthash>
#   event: Event! @index # FK?
#   block: Block! @index # FK?
#   eventIndex: Int!
#   extrinsicIndex: Int!
#   contract: Contract! # FK?
#   dataRaw: JSON!
#   dataParsed: JSON!
#   method: String!
#   type: EvmEventType!
#   status: EvmEventStatus!
#   topic0: String
#   topic1: String
#   topic2: String
#   topic3: String
# }

# ================ Token transfers ========================

# type Transfer @entity {
#   id: ID!
#   block: Block! @index
#   extrinsicId: String! @index # TODO FK
#   # to: Account!
#   # from: Account!
#   toAddress: String @index
#   fromAddress: String @index
#   tokenContract: Contract! @index
#   tokenAddress: String @index
#   toEvmAddress: String @index
#   fromEvmAddress: String @index
#   type: TransferType!
#   amount: BigInt! @index
#   feeAmount: BigInt! @index
#   denom: String @index
#   nftId: BigInt @index
#   errorMessage: String
#   success: Boolean! @index
#   timestamp: DateTime!
# }

# type TokenHolder @entity @index(fields: ["tokenAddress", "signer", "nftId"], unique: true) {
#   id: ID!
#   tokenContract: Contract! @index
#   tokenAddress: String! @unique @index
#   signer: Account
#   signerAddress: String @index
#   evmAddress: String @index
#   nftId: BigInt
#   type: TokenHolderType!
#   balance: BigInt! @index
#   info: JSON!
#   timestamp: DateTime!
# }

# =============== Contract verification ===================

# type NewlyVerifiedContractQueue @entity {

# }

# type VerificationRequest @entity {

# }

# type VerifiedContract @entity {

# }

# ===================== Staking ===========================

# type Staking @entity {
#   id: ID!
#   signer: Account
#   event: Event
#   type: StakingType! @index
#   amount: BigInt! 
#   timestamp: DateTime!
# }

# ===================== Pools =============================

# type Pool @entity {
#   id: ID!
#   address: String! @index
#   evmEvent: EvmEvent @index
#   token1: Contract! @index
#   token2: Contract! @index
#   poolDecimal: Int!
#   decimal1: Int!
#   decimal2: Int!
# }

# type PoolEvent @entity {
#   id: ID!
#   pool: Pool! @index
#   evmEvent: EvmEvent! @index
#   toAddress: String @index
#   senderAddress: String @index
#   type: PoolType! @index
#   amount1: BigInt @index
#   amount2: BigInt @index
#   amountIn1: BigInt @index
#   amountIn2: BigInt @index
#   reserved1: BigInt @index
#   reserved2: BigInt @index
#   supply: BigInt @index
#   totalSupply: BigInt @index
#   timestamp: DateTime! @index
# }

# type Candlestick @entity {

# }

# type ReservedRaw @entity {

# }

# type VolumeRaw @entity {

# }

# type TokenPrice @entity {

# }

# ===================== Enums =============================

enum EvmEventType {
  Verified, 
  Unverified
}

enum EvmEventStatus {
  Success, 
  Error
}

enum ContractType {
  ERC20, 
  ERC721, 
  ERC1155,
  other
}

enum TransferType {
  Native, 
  ERC20, 
  ERC721, 
  ERC1155
}

enum TokenHolderType {
  Account, 
  Contract
}

enum StakingType {
  Reward, 
  Slash
}

enum PoolType {
  Mint, 
  Burn, 
  Swap, 
  Sync, 
  Transfer
}

enum ExtrinsicStatus {
  success, 
  error, 
  unknown
}

enum ExtrinsicType {
  signed, 
  unsigned, 
  inherent
}